import { readFileSync, readdirSync, writeFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const questionsDir = join(__dirname, '..', 'public', 'content', 'questions');

// Import banks to get all expected subtopics
const banksFilePath = join(__dirname, '..', 'src', 'data', 'banks.ts');
let allBanks = [];
try {
  const banksContent = readFileSync(banksFilePath, 'utf-8');
  // Extract banks from the file using regex
  const bankMatches = banksContent.matchAll(/\{\s*key:\s*"([^"]+)",\s*topic:\s*"([^"]+)",\s*subtopic:\s*"([^"]+)",\s*file:\s*"([^"]+)"\s*\}/g);
  for (const match of bankMatches) {
    allBanks.push({
      key: match[1],
      topic: match[2],
      subtopic: match[3],
      file: match[4]
    });
  }
} catch (error) {
  console.warn('⚠️  Could not read banks.ts, will only show existing files');
}

/**
 * Generate statistics markdown file with problem counts by category
 */
function generateStats() {
  const stats = {
    byTopic: {},
    bySubtopic: {},
    byDifficulty: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 },
    total: 0,
    files: {}
  };

  try {
    // Read all JSON files in the questions directory
    const files = readdirSync(questionsDir).filter(f => f.endsWith('.json'));

    files.forEach(file => {
      try {
        const filePath = join(questionsDir, file);
        const content = readFileSync(filePath, 'utf-8');
        const questions = JSON.parse(content);

        if (!Array.isArray(questions)) {
          console.warn(`⚠️  ${file} does not contain an array`);
          return;
        }

        const count = questions.length;
        stats.total += count;
        stats.files[file] = count;

        // Count by topic and subtopic
        questions.forEach(q => {
          const topic = q.topic || 'Unknown';
          const subtopic = q.subtopic || 'Unknown';
          const diff = q.diff || 0;

          // Count by topic
          if (!stats.byTopic[topic]) {
            stats.byTopic[topic] = 0;
          }
          stats.byTopic[topic]++;

          // Count by subtopic (topic > subtopic)
          if (!stats.bySubtopic[topic]) {
            stats.bySubtopic[topic] = {};
          }
          if (!stats.bySubtopic[topic][subtopic]) {
            stats.bySubtopic[topic][subtopic] = 0;
          }
          stats.bySubtopic[topic][subtopic]++;

          // Count by difficulty
          if (diff >= 1 && diff <= 5) {
            stats.byDifficulty[diff]++;
          }
        });
      } catch (error) {
        console.error(`❌ Error processing ${file}:`, error.message);
      }
    });

    // Generate markdown content
    const markdown = generateMarkdown(stats);
    
    // Write to file
    const outputPath = join(__dirname, '..', 'docs', 'PROBLEM_STATISTICS.md');
    writeFileSync(outputPath, markdown, 'utf-8');
    
    console.log(`✅ Statistics generated successfully!`);
    console.log(`   Total problems: ${stats.total}`);
    console.log(`   Files processed: ${Object.keys(stats.files).length}`);
    console.log(`   Output: ${outputPath}`);
    
  } catch (error) {
    console.error('❌ Error generating statistics:', error);
    process.exit(1);
  }
}

function generateMarkdown(stats) {
  const now = new Date().toLocaleString('en-US', { 
    dateStyle: 'medium', 
    timeStyle: 'short',
    timeZone: 'UTC'
  });

  let md = `# Problem Statistics

> **Last Updated:** ${now}
> 
> This file is automatically generated. Run \`npm run generate-stats\` to update.

## Overview

- **Total Problems:** ${stats.total}
- **Question Files:** ${Object.keys(stats.files).length}

---

## Problems by Topic

`;

  // If we have banks data, include all expected subtopics
  if (allBanks.length > 0) {
    // Group banks by topic
    const banksByTopic = {};
    allBanks.forEach(bank => {
      if (!banksByTopic[bank.topic]) {
        banksByTopic[bank.topic] = [];
      }
      banksByTopic[bank.topic].push(bank);
    });

    // Sort topics alphabetically
    const topics = Object.keys(banksByTopic).sort();
    
    topics.forEach(topic => {
      const count = stats.byTopic[topic] || 0;
      const percentage = stats.total > 0 ? ((count / stats.total) * 100).toFixed(1) : '0.0';
      md += `### ${topic}\n\n`;
      md += `**Total:** ${count} problems (${percentage}%)\n\n`;
      
      md += `**Subtopics:**\n\n`;
      // Show all subtopics from banks.ts, even if they have 0 problems
      const topicBanks = banksByTopic[topic].sort((a, b) => a.subtopic.localeCompare(b.subtopic));
      topicBanks.forEach(bank => {
        const subCount = stats.bySubtopic[topic]?.[bank.subtopic] || 0;
        md += `- ${bank.subtopic}: **${subCount}** problems\n`;
      });
      md += `\n---\n\n`;
    });
  } else {
    // Fallback to original behavior if banks.ts couldn't be read
    const topics = Object.keys(stats.byTopic).sort();
    
    topics.forEach(topic => {
      const count = stats.byTopic[topic];
      const percentage = ((count / stats.total) * 100).toFixed(1);
      md += `### ${topic}\n\n`;
      md += `**Total:** ${count} problems (${percentage}%)\n\n`;
      
      // Show subtopics for this topic
      if (stats.bySubtopic[topic]) {
        const subtopics = Object.keys(stats.bySubtopic[topic]).sort();
        md += `**Subtopics:**\n\n`;
        subtopics.forEach(subtopic => {
          const subCount = stats.bySubtopic[topic][subtopic];
          md += `- ${subtopic}: **${subCount}** problems\n`;
        });
        md += `\n`;
      }
      md += `---\n\n`;
    });
  }

  md += `## Problems by Difficulty\n\n`;
  md += `| Difficulty | Count | Percentage |\n`;
  md += `|------------|-------|------------|\n`;
  
  for (let diff = 1; diff <= 5; diff++) {
    const count = stats.byDifficulty[diff];
    const percentage = stats.total > 0 ? ((count / stats.total) * 100).toFixed(1) : '0.0';
    const stars = '★'.repeat(diff);
    md += `| ${stars} (${diff}) | ${count} | ${percentage}% |\n`;
  }

  md += `\n## Problems by File\n\n`;
  md += `| File | Count |\n`;
  md += `|------|-------|\n`;
  
  // Sort files by count (descending), then alphabetically
  const files = Object.entries(stats.files)
    .sort((a, b) => {
      if (b[1] !== a[1]) return b[1] - a[1];
      return a[0].localeCompare(b[0]);
    });

  files.forEach(([file, count]) => {
    md += `| \`${file}\` | ${count} |\n`;
  });

  md += `\n---\n\n`;
  md += `*Statistics generated automatically. See \`scripts/generate-stats.js\` for details.*\n`;

  return md;
}

// Run if executed directly
generateStats();

